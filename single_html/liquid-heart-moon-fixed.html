<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Liquid Heart in Space</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Create scene
        const scene = new THREE.Scene();
        
        // Camera setup
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);
        camera.lookAt(0, 0, 0);
        
        // Create renderer with post-processing support
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000); // Black space background
        document.body.appendChild(renderer.domElement);
        
        // Add space environment - stars
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.05,
            transparent: true
        });
        
        const starVertices = [];
        for (let i = 0; i < 5000; i++) {
            const x = (Math.random() - 0.5) * 2000;
            const y = (Math.random() - 0.5) * 2000;
            const z = (Math.random() - 0.5) * 2000;
            starVertices.push(x, y, z);
        }
        
        starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        
        // Add a distant moon
        const moonGeometry = new THREE.SphereGeometry(15, 32, 32);
        const moonMaterial = new THREE.MeshStandardMaterial({
            color: 0x888888,
            roughness: 0.9,
            metalness: 0.1
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        moon.position.set(-50, 20, -100);
        scene.add(moon);
        
        // Add lights
        // Harsh directional light like the sun in space
        const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
        sunLight.position.set(10, 10, 10);
        scene.add(sunLight);
        
        // Blue-ish rim light from "Earth"
        const earthLight = new THREE.PointLight(0x4477ff, 0.5);
        earthLight.position.set(-10, -5, 5);
        scene.add(earthLight);
        
        // Ambient light to simulate light scatter
        const ambientLight = new THREE.AmbientLight(0x111111);
        scene.add(ambientLight);
        
        // Create heart shape
        function createHeartShape(size = 1) {
            const heartShape = new THREE.Shape();
            
            // Heart curve algorithm
            const x = 0, y = 0;
            heartShape.moveTo(x, y + size * 0.25);
            heartShape.bezierCurveTo(
                x, y + size * 0.25, 
                x - size * 0.4, y, 
                x - size * 0.4, y - size * 0.3
            );
            heartShape.bezierCurveTo(
                x - size * 0.4, y - size * 0.65, 
                x, y - size * 0.8, 
                x, y - size * 0.8
            );
            heartShape.bezierCurveTo(
                x, y - size * 0.8, 
                x + size * 0.4, y - size * 0.65, 
                x + size * 0.4, y - size * 0.3
            );
            heartShape.bezierCurveTo(
                x + size * 0.4, y, 
                x, y + size * 0.25, 
                x, y + size * 0.25
            );
            
            return heartShape;
        }
        
        // Use heart shape to create a BufferGeometry directly
        const heartShape = createHeartShape(1);
        const extrudeSettings = {
            depth: 0.8,
            bevelEnabled: true,
            bevelSegments: 32,
            bevelSize: 0.2,
            bevelThickness: 0.1,
            curveSegments: 128
        };
        
        // Create the heart geometry using ExtrudeBufferGeometry
        const heartGeometry = new THREE.ExtrudeBufferGeometry(heartShape, extrudeSettings);
        
        // Custom shader material for the liquid heart
        const heartMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                color: { value: new THREE.Color(0xff0505) },
                lightPos: { value: new THREE.Vector3(10, 10, 10) },
                resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                cameraPos: { value: camera.position },
            },
            vertexShader: `
                uniform float time;
                
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying vec2 vUv;
                
                // Simplex noise function
                vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }

                float snoise(vec3 v){
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                
                    // First corner
                    vec3 i  = floor(v + dot(v, C.yyy) );
                    vec3 x0 =   v - i + dot(i, C.xxx) ;
                
                    // Other corners
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min( g.xyz, l.zxy );
                    vec3 i2 = max( g.xyz, l.zxy );
                
                    vec3 x1 = x0 - i1 + 1.0 * C.xxx;
                    vec3 x2 = x0 - i2 + 2.0 * C.xxx;
                    vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;
                
                    // Permutations
                    i = mod(i, 289.0 );
                    vec4 p = permute( permute( permute(
                        i.z + vec3(0.0, i1.z, i2.z)) +
                        i.y + vec3(0.0, i1.y, i2.y)) +
                        i.x + vec3(0.0, i1.x, i2.x));
                
                    // Gradients
                    float n_ = 1.0/7.0; // N=7
                    vec3  ns = n_ * D.wyz - D.xzx;
                
                    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);
                
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_ );
                
                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                
                    vec4 b0 = vec4( x.xy, y.xy );
                    vec4 b1 = vec4( x.zw, y.zw );
                
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                
                    // Normalise gradients
                    vec4 norm = 1.79284291400159 - 0.85373472095314 * 
                        vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;
                
                    // Mix final noise value
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                                dot(p2,x2), dot(p3,x3) ) );
                }
                
                void main() {
                    vNormal = normal;
                    vPosition = position;
                    vUv = uv;
                    
                    // Create bumpy surface using noise
                    float noiseScale = 6.0;
                    float noiseTime = time * 0.5;
                    
                    // Multiple layers of noise with different frequencies
                    float noise1 = snoise(vec3(position.x * noiseScale, position.y * noiseScale, position.z * noiseScale + noiseTime)) * 0.05;
                    float noise2 = snoise(vec3(position.x * noiseScale * 2.0, position.y * noiseScale * 2.0, position.z * noiseScale * 2.0 + noiseTime * 1.2)) * 0.025;
                    float noise3 = snoise(vec3(position.x * noiseScale * 4.0, position.y * noiseScale * 4.0, position.z * noiseScale * 4.0 + noiseTime * 0.7)) * 0.0125;
                    
                    // Combine noise layers
                    float combinedNoise = noise1 + noise2 + noise3;
                    
                    // Pulsating heart effect
                    float heartbeat = (sin(time * 1.5) * 0.5 + 0.5) * 0.1;
                    float pulseFactor = 1.0 + heartbeat;
                    
                    // Low-gravity fluid wobble effect
                    float wobble = sin(time * 0.3 + position.y * 2.0) * 0.05 * sin(time * 0.7 + position.x * 2.0);
                    
                    // Apply all deformations
                    vec3 newPosition = position * (pulseFactor + wobble);
                    newPosition += normal * combinedNoise;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
                }
            `,
            fragmentShader: `
                uniform float time;
                uniform vec3 color;
                uniform vec3 lightPos;
                uniform vec3 cameraPos;
                
                varying vec3 vNormal;
                varying vec3 vPosition;
                varying vec2 vUv;
                
                void main() {
                    // Normal, view and light directions
                    vec3 normal = normalize(vNormal);
                    vec3 viewDir = normalize(cameraPos - vPosition);
                    vec3 lightDir = normalize(lightPos - vPosition);
                    
                    // Liquid red color with variations
                    vec3 baseColor = vec3(0.8, 0.05, 0.05);
                    
                    // Add color variation based on position and time
                    float colorVariation = sin(vPosition.x * 5.0 + time) * 0.1 + sin(vPosition.y * 7.0 + time * 0.7) * 0.1;
                    vec3 liquidColor = baseColor + vec3(colorVariation, colorVariation * 0.2, 0.0);
                    
                    // Basic lighting
                    float diffuse = max(dot(normal, lightDir), 0.0);
                    vec3 halfwayDir = normalize(lightDir + viewDir);
                    float specular = pow(max(dot(normal, halfwayDir), 0.0), 32.0);
                    
                    // Rim lighting effect
                    float rim = 1.0 - max(dot(viewDir, normal), 0.0);
                    rim = pow(rim, 3.0);
                    
                    // Subsurface scattering simulation
                    float sss = pow(max(dot(viewDir, -lightDir), 0.0), 2.0) * 0.5;
                    
                    // Combine lighting effects
                    vec3 finalColor = liquidColor * (0.2 + diffuse * 0.6) + vec3(1.0, 0.3, 0.2) * specular * 0.5;
                    
                    // Add rim lighting
                    finalColor += vec3(0.8, 0.1, 0.1) * rim * 0.8;
                    
                    // Add subsurface scattering
                    finalColor += vec3(0.8, 0.1, 0.0) * sss;
                    
                    // Depth-based transparency
                    float depth = length(vPosition - cameraPos);
                    float alpha = min(1.0, max(0.7, depth * 0.1));
                    
                    // Pulsating glow based on heartbeat
                    float heartbeatGlow = pow(sin(time * 1.5) * 0.5 + 0.5, 2.0) * 0.3;
                    finalColor += vec3(0.8, 0.0, 0.0) * heartbeatGlow;
                    
                    gl_FragColor = vec4(finalColor, alpha);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        // Create the heart
        const heart = new THREE.Mesh(heartGeometry, heartMaterial);
        // Rotate to orient properly
        heart.rotation.x = -Math.PI / 2;
        heart.rotation.z = Math.PI;
        heart.scale.set(1.2, 1.2, 1.2);
        scene.add(heart);
        
        // Add subtle lunar dust particles
        const particlesGeometry = new THREE.BufferGeometry();
        const particlesCnt = 1000;
        const posArray = new Float32Array(particlesCnt * 3);
        
        // Position dust particles in a sphere around the heart
        for(let i = 0; i < particlesCnt * 3; i += 3) {
            // Random position in a spherical distribution
            const radius = 2 + Math.random() * 3;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            posArray[i] = radius * Math.sin(phi) * Math.cos(theta);
            posArray[i+1] = radius * Math.sin(phi) * Math.sin(theta);
            posArray[i+2] = radius * Math.cos(phi);
        }
        
        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        
        const particlesMaterial = new THREE.PointsMaterial({
            size: 0.01,
            color: 0xaaaaaa,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        
        const particleMesh = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particleMesh);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            // Update shader time uniform
            if (heartMaterial.uniforms) {
                heartMaterial.uniforms.time.value = time;
                heartMaterial.uniforms.cameraPos.value = camera.position;
            }
            
            // Slowly rotate the heart
            heart.rotation.y = Math.sin(time * 0.2) * 0.2;
            heart.rotation.x = -Math.PI / 2 + Math.sin(time * 0.15) * 0.1;
            
            // Simulate low gravity movement - slow floating
            heart.position.y = Math.sin(time * 0.3) * 0.2;
            
            // Rotate the dust particles
            particleMesh.rotation.y = time * 0.05;
            
            // Slow rotation of stars
            stars.rotation.y = time * 0.01;
            stars.rotation.x = time * 0.005;
            
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (heartMaterial.uniforms) {
                heartMaterial.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
            }
        });
        
        // Add interactive camera movement on mouse move
        document.addEventListener('mousemove', (event) => {
            const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Smoother camera movement
            camera.position.x += (mouseX * 2 - camera.position.x) * 0.05;
            camera.position.y += (mouseY * 2 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);
        });
        
        // Start animation
        animate();
    </script>
</body>
</html>
