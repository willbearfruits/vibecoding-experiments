<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Efficient 3D Falling Stone Text</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: Arial, sans-serif;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
            z-index: 100;
        }
        input, button {
            margin: 5px;
            padding: 5px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
        }
        button:hover {
            background: #666;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div>
            <input type="text" id="textInput" value="STONE" placeholder="Enter text">
            <button id="startBtn">Drop Text</button>
            <button id="resetBtn">Reset</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Main variables
        let scene, camera, renderer;
        let textMesh, fragments = [];
        let animating = false;
        let textGroup;
        
        // Initialize scene
        init();
        animate();
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 20);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(0, 10, 5);
            pointLight.castShadow = true;
            scene.add(pointLight);
            
            // Add floor
            createFloor();
            
            // Create initial text
            createText(document.getElementById("textInput").value);
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById("startBtn").addEventListener('click', dropText);
            document.getElementById("resetBtn").addEventListener('click', resetScene);
        }
        
        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0x555555,
                roughness: 0.8,
                metalness: 0.2,
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -5;
            floor.receiveShadow = true;
            scene.add(floor);
        }
        
        function createText(text) {
            // Remove old text if exists
            if (textMesh) scene.remove(textMesh);
            if (textGroup) scene.remove(textGroup);
            
            // Create font parameters
            const fontParameters = {
                font: "bold 3px Arial",
                size: 3,
                height: 0.5,
                curveSegments: 4,
                bevelEnabled: true,
                bevelThickness: 0.2,
                bevelSize: 0.1,
                bevelOffset: 0,
                bevelSegments: 3
            };
            
            // Create text geometry
            const loader = new THREE.FontLoader();
            
            // Use Three.js default font (helvetiker)
            loader.load('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/fonts/helvetiker_bold.typeface.json', function(font) {
                const textGeometry = new THREE.TextGeometry(text, {
                    font: font,
                    size: fontParameters.size,
                    height: fontParameters.height,
                    curveSegments: fontParameters.curveSegments,
                    bevelEnabled: fontParameters.bevelEnabled,
                    bevelThickness: fontParameters.bevelThickness,
                    bevelSize: fontParameters.bevelSize,
                    bevelOffset: fontParameters.bevelOffset,
                    bevelSegments: fontParameters.bevelSegments
                });
                
                textGeometry.computeBoundingBox();
                
                // Center text
                const centerOffset = -0.5 * (textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x);
                
                // Create stone material
                const textMaterial = new THREE.MeshStandardMaterial({
                    color: 0x888888,
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                textMesh = new THREE.Mesh(textGeometry, textMaterial);
                textMesh.position.x = centerOffset;
                textMesh.position.y = 10;
                textMesh.position.z = 0;
                textMesh.castShadow = true;
                textMesh.receiveShadow = true;
                
                scene.add(textMesh);
                
                // Pre-compute fragments for later use
                prepareFragments(textGeometry, textMaterial);
            });
        }
        
        function prepareFragments(geometry, material) {
            // Reset fragments array
            fragments = [];
            
            // Create a group to hold all fragments
            textGroup = new THREE.Group();
            textGroup.visible = false;  // Hide initially
            scene.add(textGroup);
            
            // Get geometry parameters
            geometry.computeBoundingBox();
            const bbox = geometry.boundingBox;
            const centerX = -0.5 * (bbox.max.x - bbox.min.x);
            
            // Number of fragments (adjust for complexity vs performance)
            const fragmentsX = 6;
            const fragmentsY = 3;
            const fragmentsZ = 2;
            
            // Size of each fragment cell
            const cellWidth = (bbox.max.x - bbox.min.x) / fragmentsX;
            const cellHeight = (bbox.max.y - bbox.min.y) / fragmentsY;
            const cellDepth = (bbox.max.z - bbox.min.z) / fragmentsZ;
            
            // Create fragment meshes
            for (let x = 0; x < fragmentsX; x++) {
                for (let y = 0; y < fragmentsY; y++) {
                    for (let z = 0; z < fragmentsZ; z++) {
                        // Create a box for each fragment
                        const fragGeometry = new THREE.BoxGeometry(
                            cellWidth * 0.95,
                            cellHeight * 0.95,
                            cellDepth * 0.95
                        );
                        
                        // Create a slightly modified material for each fragment
                        const fragMaterial = material.clone();
                        fragMaterial.color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.1);
                        
                        // Create mesh
                        const fragMesh = new THREE.Mesh(fragGeometry, fragMaterial);
                        
                        // Position fragment
                        fragMesh.position.x = centerX + bbox.min.x + (x + 0.5) * cellWidth;
                        fragMesh.position.y = bbox.min.y + (y + 0.5) * cellHeight;
                        fragMesh.position.z = bbox.min.z + (z + 0.5) * cellDepth;
                        
                        // Add fragment data for animation
                        const fragment = {
                            mesh: fragMesh,
                            velocity: new THREE.Vector3(0, 0, 0),
                            rotVelocity: new THREE.Vector3(
                                (Math.random() - 0.5) * 0.1,
                                (Math.random() - 0.5) * 0.1,
                                (Math.random() - 0.5) * 0.1
                            ),
                            collided: false
                        };
                        
                        fragments.push(fragment);
                        fragMesh.castShadow = true;
                        fragMesh.receiveShadow = true;
                        textGroup.add(fragMesh);
                    }
                }
            }
        }
        
        function dropText() {
            if (!textMesh || animating) return;
            
            // Hide original text and show fragments
            textMesh.visible = false;
            textGroup.visible = true;
            textGroup.position.copy(textMesh.position);
            
            // Reset fragment positions
            fragments.forEach(fragment => {
                fragment.velocity.set(
                    (Math.random() - 0.5) * 0.5,  // X velocity - slight random spread
                    0,                            // Y velocity - starts at 0, gravity will pull down
                    (Math.random() - 0.5) * 0.5   // Z velocity - slight random spread
                );
                fragment.collided = false;
            });
            
            animating = true;
        }
        
        function resetScene() {
            animating = false;
            if (textMesh) {
                textMesh.visible = true;
                textMesh.position.y = 10;
            }
            if (textGroup) {
                textGroup.visible = false;
            }
            
            // If text input has changed, create new text
            const newText = document.getElementById("textInput").value;
            if (textMesh && textMesh.userData.text !== newText) {
                createText(newText);
            }
        }
        
        function updateFragments() {
            if (!animating) return;
            
            const gravity = 0.05;
            const friction = 0.98;
            const floorY = -5;
            
            let allStopped = true;
            
            fragments.forEach(fragment => {
                // Apply gravity
                fragment.velocity.y -= gravity;
                
                // Update position
                fragment.mesh.position.x += fragment.velocity.x;
                fragment.mesh.position.y += fragment.velocity.y;
                fragment.mesh.position.z += fragment.velocity.z;
                
                // Update rotation
                fragment.mesh.rotation.x += fragment.rotVelocity.x;
                fragment.mesh.rotation.y += fragment.rotVelocity.y;
                fragment.mesh.rotation.z += fragment.rotVelocity.z;
                
                // Check floor collision
                if (fragment.mesh.position.y <= floorY + 0.5) {
                    fragment.mesh.position.y = floorY + 0.5;
                    
                    if (!fragment.collided) {
                        fragment.collided = true;
                        fragment.velocity.y = -fragment.velocity.y * 0.5; // Bounce
                        fragment.velocity.x *= 0.7; // Friction
                        fragment.velocity.z *= 0.7; // Friction
                    } else {
                        fragment.velocity.y = 0;
                        fragment.velocity.x *= friction;
                        fragment.velocity.z *= friction;
                    }
                }
                
                // Check if fragment is still moving significantly
                if (Math.abs(fragment.velocity.y) > 0.01 || 
                    Math.abs(fragment.velocity.x) > 0.01 || 
                    Math.abs(fragment.velocity.z) > 0.01 ||
                    Math.abs(fragment.rotVelocity.x) > 0.001) {
                    allStopped = false;
                } else {
                    // Slowly stop rotation
                    fragment.rotVelocity.multiplyScalar(0.95);
                }
            });
            
            // If all fragments have stopped moving significantly, end animation
            if (allStopped && animating) {
                animating = false;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update fragments
            updateFragments();
            
            // Render scene
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>